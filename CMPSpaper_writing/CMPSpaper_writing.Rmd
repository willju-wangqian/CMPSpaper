---
title: An Open-Source Implementation of the CMPS Algorithm for Assessing  Similarity of Bullets
header-includes:
  - \usepackage{amsmath}
  - \usepackage{xcolor}
  - \usepackage{longtable}
  - \usepackage{adjustbox}            
  - \usepackage[font=small,skip=5pt]{caption}
  - \usepackage{subcaption}
  - \usepackage{afterpage}
  - \usepackage{bbm}
author:
  # see ?rjournal_article for more information
  - name: Wangqian W. Ju
    affiliation: Department of Statistics
    address:
    - Center for Statistics and Applications in Forensic Evidence
    - Iowa State University
    - 2438 Osborn Dr
    - Ames, IA 50011
    url: https://github.com/willju-wangqian
    email:  wju@iastate.edu
    orcid: 0000-0002-9977-377X
  - name: Heike Hofmann
    url: https://github.com/heike
    email: hofmann@iastate.edu
    orcid: 0000-0002-9079-593X
    affiliation: Department of Statistics
    address:
    - Center for Statistics and Applications in Forensic Evidence
    - Iowa State University
    - 2438 Osborn Dr
    - Ames, IA 50011
thanks: |
  This work was partially funded by the Center for Statistics and Applications in Forensic Evidence (CSAFE) through Cooperative Agreement 70NANB20H019 between NIST and Iowa State University, which includes activities carried out at Carnegie Mellon University, Duke University, University of California Irvine, University of Virginia, West Virginia University, University of Pennsylvania, Swarthmore College and University of Nebraska, Lincoln.    
abstract: >
  In this paper we introduce the R package CMPS, an open-source implementation of the Congruent Matching Profile Segments (CMPS) method developed at the National Institute of Standards and Technology (NIST) for objective comparison of striated tool marks. The functionality of the package is showcased by examples of bullet signatures that come with the package. Graphing tools are implemented in the package as well for users to assess and understand the CMPS results. Initial tests were performed on bullet signatures generated from two sets of 3D scans in Hamby study under the framework suggested by R package bulletxtrctr. An open-source implementation facilitates further studies of the algorithm such as cross-validation of parameters and methods comparison.
preamble: |
  % Any extra LaTeX you need in the preamble
  
bibliography: CMPSpaper-writing.bib
output: rticles::rjournal_article
editor_options: 
  chunk_output_type: inline
---


```{=tex}
\newcommand{\hh}[1]{{\textcolor{orange}{#1}}}
\newcommand{\wj}[1]{{\textcolor{blue}{#1}}}
\setlength{\parindent}{0pt}
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(tidyverse)
library(bulletxtrctr)
library(knitr)
library(kableExtra)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "\\textwidth",
  fig.align = "center",
#  cache=TRUE,
  dpi = 100
)
```


```{r setup_knitr, echo=FALSE}
## From Josh O'Brien's stackoverflow answer:
## http://stackoverflow.com/questions/11030898/knitr-how-to-align-code-and-plot-side-by-side
## These two settings control text width in codefig vs. usual code blocks
partWidth <- 35
fullWidth <- 60
options(width = fullWidth)

##  (1) CHUNK HOOK FUNCTION
##   First, to set R's textual output width on a per-chunk basis, we
## need to define a hook function which temporarily resets global R's
## option() settings, just for the current chunk
knit_hooks$set(r.opts = local({
    ropts <- NA
    function(before, options, envir) {
        if (before) {
            ropts <<- options(options$r.opts)
        } else {
            options(ropts)
        }
    }
}))

## (2) OUTPUT HOOK FUNCTION

##   Define a custom output hook function. This function processes _all_
## evaluated chunks, but will return the same output as the usual one,
## UNLESS a 'codefig' argument appeared in the chunk's header.  In that
## case, wrap the usual textual output in LaTeX code placing it in a
## narrower adjustbox environment and setting the graphics that it
## produced in another box beside it.

defaultChunkHook <- environment(knit_hooks[["get"]])$defaults$chunk

codefigChunkHook <- function(x, options) {
  main <-  defaultChunkHook(x, options)
  before <-
    "\\vspace{1em}
\\begin{adjustbox}{valign=t}
\\begin{minipage}{.39\\textwidth}\n"
  after <-
    paste("\\vspace{1em}
\\end{minipage}
\\begin{minipage}{.59\\textwidth}",
    paste0("\\includegraphics[width=\\textwidth]{CMPSpaper_writing_files/figure-latex/",
                 options[["label"]], "-1.pdf}
\\end{minipage}
\\end{adjustbox}"),
          sep = "\n")
  ## Was a codefig option supplied in chunk header?
  ## If so, wrap code block and graphical output with needed LaTeX code.
  if (!is.null(options$codefig)) {
    main <- gsub("```","", main)
    main <- gsub("=latex","", main)
    main <- paste0("{\\small ", main, "}")
    return(sprintf("%s\n%s\n%s", before, main, after))
  } else {
    return(main)
  }
}

knit_hooks[["set"]](chunk = codefigChunkHook)


## (3) TEMPLATE
##   codefig=TRUE is just one of several options needed for the
## side-by-side code block and a figure to come out right. Rather
## than typing out each of them in every single chunk header, we
## define a _template_ which bundles them all together. Then we can
## set all of those options simply by typing opts.label="codefig".

opts_template[["set"]](
codefig = list(codefig = TRUE, fig.show = "hide",
               r.opts = list(width = partWidth),
               tidy.opts = list(width.cutoff = partWidth)))
```




## Introduction


In this paper we present an open-source implementation of the algorithm of the Congruent Matching Profile Segments (CMPS) method. @cmps developed the CMPS method for "objective comparison of striated tool marks" and demonstrated its use in some examples of comparing bullet signature correlations. Although @cmps conceptually described the CMPS algorithm  in their paper, the authors did not release an implementation of their method. Thus, our effort here is to introduce the CMPS method to the `R` [@R] community and provide an open-source, publicly available implementation of the algorithm  to use, review, and  improve. Our implementation is made available as part of the  `R` package  `CMPS` on GitHub at \url{https://github.com/willju-wangqian/CMPS}. 

According to the Uniform Crime Reporting Program of FBI (Federal Bureau of Investigation), "More than 73 percent (73.7) of the homicides for which the FBI received weapons data in 2019 involved the use of firearms" [@fbiucr], and firearm examination could play an important role in all these cases.
 <!-- Firearm examination has  played an important role in  convictions [@fbiucr] in the United States criminal justice system. \hh{Do we have a number or a percentage of cases where firearm examination has played a role? or maybe gun violence? XXX} -->
<!-- https://ucr.fbi.gov/crime-in-the-u.s/2019/crime-in-the-u.s.-2019/topic-pages/expanded-homicide -->
An important task of firearm examination is to answer the question of whether two pieces of evidence come from the same source or whether a piece of evidence matches a sample obtained from a specific firearm. Here, in particular, we are interested to determine whether two bullets were fired from the same gun barrel. 
Assessing the similarity between two bullets is based on a comparison of  striation marks acquired during the firing process as bullets are propelled through the barrel. Current state of art sees firearms examiners make an assessment of similarity based on a visual comparison, generally, using a comparison microscope. This practice has been criticized for its lack of objectivity and the associated problem in calculating an error rate [@pcast].

A report published by @nrc states that "[m]uch forensic evidence-including, for example, bite marks and firearm and toolmark identificationâ€”is introduced in criminal trials without any meaningful scientific validation, determination of error rates, or reliability testing to explain the limits of the discipline." To overcome those criticisms and concerns, researchers have been making an effort to build databases and develop frameworks and algorithms that bring an objective and quantitative assessment into the field [@nistdb, @brundage, @hamby, @Hamby:2019, @song2005, @ChumbleyL_Scott2010VoTM, @aoas, @pmid30444940;@cmps]. Note that this is not an exhaustive list of these efforts. The notion of bullet signatures is one of the results of these efforts. Bullet signatures can be extracted from bullet land engraved areas (LEAs), typically one for each land engraved area, and how those bullet signatures are extracted from scans will be discussed in the Background section. Since bullet signatures can numerically describe the striation marks on the bullet and can be understood by algorithms, they played an important role in bringing objectivity into the field. 
In the following sections we will: review the background of bullet signature comparisons, discuss how we followed the idea described by @cmps for the implementation of the CMPS algorithm, and present results of applying our implementation to real data. 

## Background 


### Hamby Data Set

The datasets we worked with come from the James Hamby Consecutively Rifled Ruger Barrel Study [@brundage; @hamby; @Hamby:2019],  in particular, Hamby set 252 and Hamby set 44. 
For each Hamby set, a total of 35 bullets is fired from ten consecutively manufactured Ruger P-85 pistol barrels. Two bullets are fired from each barrel, making up a set of 20 reference bullets. An additional 15 bullets are fired from these ten barrels in a fashion unknown to the study participant. The aim of the Hamby Study was to have firearms examiners identify which barrel each of the 15 questioned bullets was fired from. The Ruger P-85 barrels are traditionally rifled barrels with six grooves and lands as shown in \autoref{fig:bullet}. During the firing process, grooves and lands are engraved on a bullet. Firearms examiners use striation marks on land engraved areas (LEAs) for their visual comparison. For algorithmic purposes, 
3D topographical images of land engraved areas were obtained and stored in  x3p format (XML 3-D Surface Profile). The x3p format provides a standard way of exchanging 2D and 3D profile data. It conforms to the ISO5436-2 standard [http://sourceforge.net/p/open-gps/mwiki/X3p/]  adopted by the OpenFMC (Open Forensic Metrology Consortium), a group of firearm forensics researchers who contributes to the establishment of best practices of using metrology in forensic science. Hamby set 252 were scanned using a NanoFocus lens at 20x magnification with the scan resolution being 1.5625 \textmu m $\times$ 1.5625 \textmu m per pixel. Hamby set 44 was scanned at the Roy J Carver High-Resolution microscopy lab at Iowa State. These scans were acquired with a Sensofar Confocal Light Microscope at 20x magnification for a nominal resolution of 0.645 \textmu m $\times$ 0.645 \textmu m per pixel.  Both Hamby set 252 and Hamby set 44 are publicly available on the NIST Ballistics Database Project [@nistdb].


### Extracting signatures from LEA scans

The automated framework  used in this paper was proposed by @aoas. In order to obtain bullet signatures from the x3p files of bullet land engravings, we use the `R` packages `x3ptools` [@x3ptools] and `bulletxtrctr` [@bulletxtrctr]. `x3ptools` is a package to read, write, and generally, process x3p files. The `bulletxtrctr` package implements a pipeline for extracting and comparing signatures from scans of land-engraved areas.

\autoref{fig:process} gives an overview of all of the steps in the process from scan to signatures.
\autoref{fig:process}(a) shows a rendering of a 3d scan of a bullet land  engraved area. The raised portion of the surface on the left and right of the scan are parts of the adjacent groove engraved areas (GEAs), the middle area shows a land-engraved area (LEA) with well expressed striation marks. The first step of obtaining the bullet signature is to extract a cross-section at a fixed height along the land engraving.

The white horizontal line in \autoref{fig:process}(a) indicates which cross-section was identified by the algorithm to represent the LEA; \autoref{fig:process}(b) shows the corresponding cross-sectional view. 
Groove engraved areas are removed from the analysis as indicated by the vertical blue lines in \autoref{fig:process}(c) and \autoref{fig:process}(d)). A non-parametric LOESS smooth  [@loess] is fitted to capture the bullet curvature (\autoref{fig:process}(e)) and, finally, the **bullet signature** (\autoref{fig:process}(f)) is obtained as residuals of the cross-section and the fitted smooth. 
Note, that in @cmps bullet signatures are  referred to as bullet profiles. However, to avoid confusion, we distinguish the notion of bullet signatures from bullet profiles. Bullet profiles are shown in panels (b), (c), and (d) of \autoref{fig:process}, while \autoref{fig:process}(f) shows the corresponding bullet signature.
Identifying the groove engraved areas correctly is fundamental for a correct down-stream analysis of the signatures. To allow for a human-in-the middle inspection and intervention we have provided an interactive web-application, implemented as `R` Shiny App [@shiny],  `bulletinspectR` to identify and correct those errors. 
An example of the extraction process with corresponding code and parameter settings can be found on Github at \url{https://github.com/willju-wangqian/CMPSpaper/tree/main/reproducible}
Note that the process of extracting signatures might be different from the one used in @cmps because no code or parameter settings are made available publicly.


```{r bullet, echo=FALSE, out.width=".8\\textwidth", fig.cap="Photo of a traditionally rifled gun barrel (left) and a fired bullet (right)."}
knitr::include_graphics("img/barrel_bullet_ps.png", dpi = 100)
```


```{r process, echo=FALSE, out.width=".9\\textwidth", fig.cap="A framework of obtaining a bullet signature. (a) front view of a scanned land engraved area (LEA). The selected crosscut location is indicated by the white line. (b) view of the cross-section of the land engraved area at the white line in (a). (c) the crosscut data plotted in 2D; blue vertical lines indicate the position of left and right grooves. (d) the crosscut data after chopping the left and right grooves. (e) the fitted curvature using LOESS. (f) after removing the curvature from the crosscut data, the bullet signature is obtained"}
knitr::include_graphics("img/figure1_v2.PNG", dpi = 100)
```




### Conceptual idea of CMPS
Most algorithms for comparing striation marks are based on the digitized signatures and produce a similarity score [@song2005, @ChumbleyL_Scott2010VoTM, @aoas, @pmid30444940 ].
 The congruent matching profile segments (CMPS) algorithm, developed by @cmps for "objective comparison of striated tool marks", is one such algorithm. The algorithm's main idea  is to take a set of consecutive and non-overlapping basis segments from  the comparison  and  for each segment find the "best" registration position on the reference  (the other bullet signature) with respect to their cross-correlation values. From a comparison of these registration positions, a **congruent registration position** is identified, and the number of basis segments taking the congruent registration position is the CMPS score. Note that researchers in @cmps refers the origin of basis segments as the reference, but in this paper we refer it as the comparison.
  High CMPS scores are achieved between more similar signatures and are therefore indicative of a same-source pair. Low scores between pairs of signatures are attributed to different source pairs.
However, a specific threshold of the CMPS score to distinguish between same-source and different-source comparisons is not mentioned in @cmps and depends on the underlying structure of the data and the choice of parameters. Further research is needed to understand how to determine the threshold.
  <!-- \hh{XXX What threshold did @cmps identify as the boundary between different source and same source? And what was the error rate in their example?} -->
  <!-- \wj{they didn't talk about a specific threshold or error rates} \hh{XXX Is there a way to infer the error based on the example? ... 'while the authors did not mention a specific threshold of the CMPS to distinguish between same-source and different-source comparison, a CMPS value of Y results in an error rate of Z in the example.'} -->
 The CMPS algorithm can assist firearm examiners with drawing a conclusion about the source of a comparison pair. Unfortunately, @cmps did not release any code or specific parameter settings for their implementation of the CMPS algorithm. 
Thus, in this paper we present an open-source implementation of the CMPS algorithm in the R package CMPS available from Github \url{https://github.com/willju-wangqian/CMPS}
With our implementation, one can compute the CMPS score of a comparison using the following code:

```{r, eval=FALSE}
# install.packages("devtools") 
# devtools::install_github("willju-wangqian/CMPS")

library(CMPS)
data(bullets)

sig1 <- bullets$sigs[[2]]$sig
sig2 <- bullets$sigs[[9]]$sig
sig3 <- bullets$sigs[[10]]$sig

cmps.result.KM <- extract_feature_cmps(sig1, sig2)
cmps.result.KNM <- extract_feature_cmps(sig1, sig3)
```

In this example, the comparison between `sig1` and `sig2`, two signatures coming from the same source (a known-match comparison), gets a CMPS score of 17; the comparison between `sig1` and `sig3`, two signatures coming from different sources (a known non-match comparison), gets a CMPS score of 1.


We also implemented graphing tools for users to better understand these results as well as the algorithm itself.

The section "Implementation" will go through the algorithm and show how to use the "CMPS" package. A further example that illustrates the main points are also included. The section "Results" presents the results of evaluating the CMPS package using Hamby set 252 and Hamby set 44. And the last section covers some final discussion and conclusions.


## Implementation

**Algorithm.** 

Conceptually, the CMPS algorithm consists of three main steps:

1. **cut the comparison signature into consecutive, non-overlapping and equal-length basis segments:**
The command `get_segs(x, len=50)` implements this step:  it takes  bullet signature `x` in the format of a numeric vector and cuts it into consecutive, non-overlapping and equal-length segments of length `len`, which are referred to as "basis segments".

2. **identify candidate positions:** For each basis segment a set of candidate registration  positions on the comparison signature is identified based on the segment's similarity to the reference signature. In a first step, the cross-correlation function of the segment to the reference is calculated, then a number of positions with high correlation values are identified as candidate positions. In case multiple segment lengths are considered, the length of each basis segment is doubled and these two steps are repeated. Only when candidate positions coincide (or are similar enough), they are considered further. \autoref{fig:segplots} and \autoref{fig:seg_all} illustrate these ideas.
    + **Calculate the cross-correlation curve:**  Calculate the cross-correlation curve between a basis segment `x` and the reference signature `y` using the function `get_ccf4(x, y, ...)` as shown in \autoref{fig:segplot2}. The position indicates the lag by which a basis segment is moved with respect to its original placement. A position is considered "good" if it results in a peak in the cross-correlation between the basis segment and the reference.
    + **Correlation peaks:** Two strategies referred to as "multi-peak inspection" and "multi-peak inspection at different segment lengths" in @cmps are used for identifying positions of correlation peaks as candidate positions. The latter is also called "multi-segment lengths strategy". The parameter `npeaks.set` in `extract_feature_cmps(...)` determines which strategy to use and the number of candidate positions: 
        -   If `npeaks.set` is an integer vector of length 1, for example `npeaks.set = 5`, the positions of the top five peaks in the cross-correlation curve are identified as candidate positions for registration. 
        -   If `npeaks.set` is an integer vector of length more than 1, for example `npeaks.set = c(5, 3, 1)`, the multi-segment lengths strategy will be used: find the top five peaks at the first level, double the segment length and recalculate the cross-correlation function, then identify 3 peaks at the second level and repeat the process for a basis segment that is doubled again to identify 1 peak at the third level. \autoref{fig:seg_all} shows an example of three levels of basis segment 6 and their corresponding cross-correlation curves and identified peaks.
        -   `get_ccr_peaks(comp, segments, seg_scale, nseg = 1, npeaks = 5)` computes the cross-correlation curve between a basis or scaled segment and the reference signature and finds peaks in the cross-correlation curve. The number of peaks detected is equal to `npeaks`, which is an integer. `segments`, `seg_scale`, and `nseg` determines the segment in the cross-correlation computation, and `comp` gives the reference signature. If the multi-segment lengths strategy is used, then `get_ccr_peaks(...)` is called in a `lapply()` for each level of the basis segment. The resulting list is called `ccr.list`.
    +  **multi-segment lengths strategy:** with the multi-segment lengths strategy being used, a position is identified as a candidate position for registration and is called as a "consistent correlation peak" if it results in a top peak in the cross-correlation curve with a tolerance zone determined by `Tx` in all segment levels Note that in @cmps, a segment at its largest scale (highest level) always identifies one peak.
        -   the function `get_seg_scale(segments, nseg, scale = 2)` is used to obtain the scaled version of a basis segment. `segments` is a list containing all basis segments, generated by the function `get_segs(...)` in step 1; `nseg` is an integer indicating which basis segment the function should work with. `scale=1` gives the original length of the basis segment. Increasing `scale` by 1 will double the segment length. 
        -   `get_ccp(ccr.list, Tx = 25)` tries to identify the "consistent correlation peak". `ccr.list` is the result of `lapply()` and `get_ccr_peaks(...)`, and `Tx` determines the size of a tolerance zone used in identifying the consistent correlation peak. `get_ccp(...)` returns `NULL` if there is no consistent correlation peak.

3. **determine the congruent registration position:** A candidate position "receives" `votes` from basis segments that identify it or a close position within a tolerance zone of `Tx` as a candidate position in step 2. Votes for all candidate positions are tallied, and the position with the highest number of votes gets chosen as the *congruent registration position*,  indicating that most of the basis segments find their highly similar counterpart in the reference signature in terms of correlation at this registration position. In case of ties the middle position is taken as the congruent registration position. Basis segments with a congruent registration position are called "congruent matching profile segments" (CMPS). The total number of CMPS is the CMPS score of the comparison. `get_CMPS(input.ccp, Tx = 25)` is the function that tallies the votes and determines the congruent registration position and congruent matching profile segments (cmps).

<!-- In the CMPS package, these three steps are implemented using a set of key functions: -->

Note that there are several parameters in the CMPS algorithm that are left to the users to decide, such as the length of basis segments `seg_length` in step 1, the number of peaks `npeaks.set` identified on each level in step 2, and the length of the tolerance zone `Tx` in both step 2 and 3. 
In our implementation of the CMPS algorithm we used the parameters given in the original CMPS paper [@cmps] as the default values for these parameters. However, the authors state that no cross-validation has been done - there might be also issues with respect to resolution of the scans. Further research is needed, until then users are advised to think of default values as starting values and consider alternatives.
<!--Additionally, as shown in @cmps, using multi-segment lengths strategy reduces the number of "false positive" peaks in the cross-correlation curves, thus providing a more conservative way of identifying candidate positions.-->
The main function that combines all steps in the CMPS algorithm described above is called `extract_feature_cmps(...)`. Here we present it with its default parameters.

```{r, eval=FALSE}
extract_feature_cmps(
  x,
  y,
  seg_length = 50,
  Tx = 25,
  npeaks.set = c(5, 3, 1),
  include = NULL
)
```

The function `extract_feature_cmps` allows for the following input from users besides the previously discussed parameters `seg_length`, `npeaks.set`, and `Tx`:

* `x` and `y` are  two  signatures:  `x` serves as the comparison signature (which will be divided into basis segments) and `y` is the reference signature;

* `include` determines the format of the function result. Besides the `CMPS.score`, other aspects of the comparison help in understanding how the `CMPS.score` is computed. By default `include` is set to `NULL` and  only  the `CMPS.score` is returned; further results are included when `include` is (an abbreviation of) one of or a vector of the following strings: `"nseg", "congruent.pos", "congruent.seg.idx", "segments", "parameters"`, and `"full_result"`. If `include` is specified as `"full_result"` (or its abbreviation), the ouput includes everything listed below.
  - `nseg`: the number of basis segments  from the comparison signature; this is also the highest possible CMPS score of the comparison;
  - `congruent.pos`: the congruent registration position;
  - `congruent.seg.idx`: the indices of all congruent matching profile segments;
  - `ccp.list`: a list showing identified candidate positions of all basis segments; 
  - `pos.df`: a data frame containing all candidate positions and their respective number of votes;
  - `segments`: a list containing all basis segments;
  - `parameters`: a list containing all input arguments of `extract_feature_cmps`;
  
<!--For more details, please check the documentation of `extract_feature_cmps` or use `?extract_feature_cmps`.-->

<!-- [examples https://journal.r-project.org/archive/2019/RJ-2019-044/RJ-2019-044.pdf] -->
<!-- [https://journal.r-project.org/archive/2019/RJ-2019-002/RJ-2019-002.pdf] -->

In the remainder of the paper we showcase the use of the CMPS functionality on some examples and present the results of applying it to two datasets.
<!-- \hh{XXX you need a bit of an overview here on the structure of what is coming next: in the remainder of the paper we showcase the use of the CMPS functionality on some examples ...} -->

**Installation**

The CMPS package is not publicly available from CRAN yet, and its development version is available from Github and can be installed by

<!-- ```{r, eval=FALSE} -->
<!-- install.packages("CMPS") -->
<!-- ``` -->

<!-- The development version is available from Github can be installed by using  -->

```{r, eval=FALSE}
# install.packages("remotes") 
remotes::install_github("willju-wangqian/CMPS")
```



**An Example**

The `CMPS` package contains a simple example to illustrate the basic usage of the package. The data in this example are twelve bullet signatures obtained from two bullets in Hamby set 252 [@hamby].  The procedure for generating signatures from high-resolution 3D topographic scans of bullet lands used here follows the methodology described in @aoas (as discussed above). 
The two bullets under consideration are known to have been fired from the same gun barrel, so for the 36 pairwise land-by-land comparisons, six comparisons are from same-source pairs (known matches) while thirty are from different-source pairs (known non-matches). To access the example data, we use

```{r, eval=TRUE}
library(CMPS)
data(bullets)
```

`bullets$sigs` is a list of twelve numeric vectors corresponding to the twelve bullet signatures shown in \autoref{fig:sigs}. `bullets$source` contains the URLs to the corresponding x3p file containing the topographic scan  from the NIST Ballistics Toolmark Research Database [@nistdb]. 

```{r sigs, echo=FALSE, fig.cap="Signatures of all lands of bullet 1 in the top row, and of bullet 2 in the bottom row. Signatures in the second row are ordered to be in phase with the signatures above, i.e. matching signatures are displayed on top of each other."}
signatures <- bullets %>% unnest(sigs)
signatures <- signatures %>% mutate(
  bulletland = factor(bulletland, levels=c(paste(rep(c(1,2), each=6), c(1:6,2:6,1), sep="-")))
)
signatures %>% ggplot(aes(x = x/1000, y = sig)) + geom_line() + facet_wrap(~bulletland, ncol=6) +
  theme_bw() +
  xlab("Length in mm") +
  ylab("Relative height in micron")
```

The signatures of Land 4 of Bullet 1 and Land 5 of Bullet 2 are stored in objects `sigs2` and `sigs1`, respectively. This comparison consists of a pair of signatures that are known to be a match -- a KM (known match) comparison. We compute the CMPS score using two versions of the CMPS algorithm:




```{r, eval=TRUE}
sigs1 <- bullets$sigs[bullets$bulletland == "2-5"][[1]]
sigs2 <- bullets$sigs[bullets$bulletland == "1-4"][[1]]

# compute cmps

# algorithm with multi-peak insepction at three different segment levels
cmps_with_multi_scale <- 
  extract_feature_cmps(sigs1$sig, sigs2$sig, 
                       npeaks.set = c(5,3,1), include = "full_result")

# algorithm with multi-peak inspection at the basis scale only
cmps_without_multi_scale <- 
  extract_feature_cmps(sigs1$sig, sigs2$sig, 
                       npeaks.set = 5, include = "full_result")
```


In the first example, `npeaks.set` is a vector of three integers, i.e.  the algorithm uses the multi-segment lengths strategy to create the result object `cmps_with_multi_scale`.  For `cmps_without_multi_scale` each basis segment is linked to the top 5 candidate positions. 
We use `include = "full_result"` to capture all results. In this example, the CMPS is 9 when using multiple segments, and 12 when using a single segment. As discussed in @cmps, using multi-segment lengths strategy can reduce the number of false positives when identifying candidate positions; however, any score based method is walking the line between false positives and false negatives. As the number of false positives is reduced the number of false negatives might rise. More discussion and comparisons between the two versions of the CMPS algorithm will be presented in later sections. Note, that the multi-segment lengths method is slower because the algorithm is run once for each segment length.


<!-- \wj{XXX as mentioned before, }multi-segment lengths strategy provides a more conservative ways of finding candidate positions, so the `CMPS.score` of `cmps_with_multi_scale` is 9, while that of `cmps_without_multi_scale` is 12. \wj{XXX how should we address the advantage of multi-segment lengths strategy} \hh{XXX any score based method is walking the line between false positives and false negatives. As the number of false positives is reduced (by being more conservatives) the number of false negatives might rise. The multi scale method might also be slower because the algorithm is run a couple of times.} -->

<!-- \hh{XXX this is just a single example - a claim of 'more conservative' is quite big. At this point, it is only a claim. How would you go about finding evidence for it? } -->

```{r alternative, echo = FALSE}
lands <- unique(bullets$bulletland)

comparisons <- data.frame(expand.grid(land1 = lands[1:6], land2 = lands[7:12]), 
                          stringsAsFactors = FALSE)

comparisons <- comparisons %>% 
  left_join(bullets %>% select(bulletland, sig1=sigs),
            by = c("land1" = "bulletland")) %>%
  left_join(bullets %>% select(bulletland, sig2=sigs),
            by = c("land2" = "bulletland"))

comparisons <- comparisons %>% mutate(
  cmps = purrr::map2(sig1, sig2, .f = function(x, y) {
    extract_feature_cmps(x$sig, y$sig, include = "full")
    })
)

comparisons <- comparisons %>% 
  mutate(
    cmps_score = sapply(comparisons$cmps, function(x) x$CMPS.score),
    cmps_nseg = sapply(comparisons$cmps, function(x) x$nseg)
  )

comparisons <- comparisons %>%
  mutate(
    bulletA = gsub("(\\d)-\\d", "\\1", land1),
    landA = gsub("\\d-(\\d)", "\\1", land1),
    bulletB = gsub("(\\d)-\\d", "\\1", land2),
    landB = gsub("\\d-(\\d)", "\\1", land2)
  )

dframe <- comparisons %>% select(-sig1, -sig2)

dframe$samesource <- with(dframe, bullet_to_land_predict(land1=landA, land2=landB, cmps_score, difference=1))
```

**Visualize and Understand CMPS results**

We also implemented graphing tools for visualizing results of the CMPS algorithm. The goal is to provide users with tools to inspect each of the basis segments and to help them have a better understanding of how the algorithm works. \autoref{fig:sigplots} shows the plots generated by the first graphing function, `cmps_signature_plot()`, and continues with the example above. `cmps_signature_plot()` takes the output of `extract_feature_cmps(..., include = "full_result")` and returns a list of 5 elements. It creates an overall impression of how the comparison signature aligns with the reference signature at the congruent registration position.

*   The first element is a plot called `segment_shift_plot`, shown in \autoref{fig:sigplot}. On this plot the reference signature is drawn as a black line,  congruent matching profile segments from the comparison signature are overlaid in red at the congruent registration position. 

<!-- basis segments that agree with the congruent registration position (i.e. the segments that are congruent matching profile segments) are plotted along with the comparison signature. When plotting, each of those basis segments will be shifted to the position where the basis segment obtains a cross-correlation peak and is within the tolerance zone of the congruent registration position. -->

*   The second plot is called `signature_shift_plot`, shown in \autoref{fig:sigplot2}. This visual presents both the comparison signature and the reference signature. The comparison signature is aligned with the reference signature based on the congruent registration position. Congruent matching profile segments are highlighted by  solid red lines. 

\begin{figure}[hbt]
\begin{subfigure}[t]{\textwidth}
\caption{\label{fig:sigplot}The black line shows the comparison signature; each red line segment shows one congruent matching profile segment.}
```{r sigplot, opts.label="codefig", echo=TRUE, out.width='\\textwidth', warning = FALSE}
sig.plot <- cmps_signature_plot(
  cmps_with_multi_scale
)
sig.plot$segment_shift_plot
```
\end{subfigure}
\begin{subfigure}[t]{\textwidth}
\caption{\label{fig:sigplot2}The black line shows the reference signature; the red line shows the comparison signature. Solid part shows the congruent matching profile segments, and the dashed part shows segments that do not agree with the congruent registration position.}
```{r sigplot2, opts.label="codefig", echo=TRUE, out.width='\\textwidth', warning = FALSE}
sig.plot$signature_shift_plot
```
\end{subfigure}
\caption{\label{fig:sigplots} Two visual outputs of cmps\_signature\_plot()}
\end{figure}

*   Other elements of this list are `seg_shift` and `sig_shift`. `sig_shift` gives the congruent registration position, while `seg_shift` is a data frame showing the congruent matching profile segments and their identified candidate position closest to the congruent registration position.

```{r, echo=TRUE, eval=TRUE}
sig.plot$seg_shift
```

<!-- These elements are essentially used for generating visuals above but also provide insights about the congruent registration position and the candidate positions found by each of the congruent matching profile segments.  -->
<!-- which basis segments are the congruent matching profile segments. -->

While `cmps_signature_plot()` focuses on the signature level,  `cmps_segment_plot()` focuses on the segment level. It provides the "full result" of `extract_feature_cmps()`, but also takes an argument, `seg.idx`, indicating which segment should be inspected.  When checking `sig.plot$seg_shift` we notice that  segment number 6 is not one of the congruent matching profile segments. We can therefore set `seg.idx = 6` in `cmps_segment_plot()` and investigate the reason why this segment disagrees with the congruent registration position.

For each segment scale, we have two plots: `segment_plot` and `scale_ccf_plot`, as shown in \autoref{fig:segplots} for the example of segment number 6: 

*   \autoref{fig:segplot} is the `segment_plot` for basis segment 6 at level one (in its original length). We used  `npeaks.set = c(5, 3, 1)` in `extract_feature_cmps()` when calculating the CMPS score. Therefore the top five peaks are identified in the cross-correlation curve at level one. Segment 6 is plotted at the positions where these 5 peaks are identified with dashed lines in the `segment_plot`. The solid thick black line shows the segment at its original position (which in this example is very close to the actual registration position). 
*   \autoref{fig:segplot2} is the `scale_ccf_plot` of basis segment 6 at level one. It shows the cross-correlation curve computed by the reference signature and the level-one basis segment 6. The five highest peaks are marked by dots on the curve.

\begin{figure}
\begin{subfigure}[t]{\textwidth}
\caption{\label{fig:segplot}segment\_plot for segment 6 at level one. The original position of segment 6 is indicated by the solid black line. Positions where the segment achieves the 5 highest cross-correlations are indicated by the dashed line segments.}
```{r segplot, opts.label="codefig", echo=TRUE, out.width='\\textwidth', warning = FALSE}
seg.plot <- cmps_segment_plot(
  cmps_with_multi_scale, 
  seg.idx = 6
)
seg.plot[[1]]$segment_plot
```
\end{subfigure}
\begin{subfigure}[t]{\textwidth}
\caption{\label{fig:segplot2}scale\_ccf\_plot shows the cross-correlation curve between the reference signature and segment 6 at level one. The five highest peaks are marked by dots. The vertical red dashed line indicates the congruent registration position; the green dashed line shows a peak position in the highest segment level; the blue dashed lines show the tolerance zone around the green dashed line. We can see that none of the five highest peaks at level one falls within the tolerance zone, indicating that there is no consistent correlation peak or a candidate position identified by basis segment 6 under the multi-segment lengths strategy. Thus, the basis segment 6 doesn't vote for the congruent registration position and is not a cmps.}
```{r segplot2, opts.label="codefig", echo=TRUE, out.width='\\textwidth', warning = FALSE}
seg.plot[[1]]$scale_ccf_plot
```
\end{subfigure}
\caption{\label{fig:segplots} Two plots used to investigate basis segment 6 at level one}
\end{figure}

Additionally, users can have more insights about why segment 6 is not a congruent matching profile segment if we put the `segment_plot` and `scale_ccf_plot` of all three segment levels together, as shown in \autoref{fig:seg_all} with the help of `ggpubr::ggarrange()`.

\begin{figure}
```{r segplot3, opts.label="codefig", echo=TRUE, out.width='\\textwidth', warning = FALSE}
library(ggpubr)

ggarrange(
  plotlist = 
    unlist(seg.plot, 
           recursive = FALSE),
  ncol = 2, 
  nrow = 3)
```
\caption{\label{fig:seg_all} Put segment\_plot and scale\_ccf\_plot of all three levels together. We are identifying five highest peaks at level one, three peaks at level two, and one peak at level three since npeaks.set = c(5, 3, 1). The highest peak position at level three is marked by the green dashed line across all segment levels. However, the highest peak on level three does not coincide with any of the top five highest peaks at level one. This indicates that there is no consistent correlation peak or a candidate position for basis segment 6 under the multi-segment lengths strategy.}
\end{figure}


In \autoref{fig:seg_all}, the red vertical dashed line indicates the congruent registration position. We can see that the basis segment 6 does obtain a peak near the congruent registration position at level two and level three, respectively; however, this position doesn't give one of the five highest peaks at level one. As a result, segment 6 fails to identify the consistent correlation peak (ccp) and fails to become one of the congruent matching profile segments according to the multi-segment lengths strategy. The identified top five peaks at level one are also examples of "false positive" peaks. The "true positive" peak (the peak within the tolerance zone of the congruent registration position) is identified at level two and three by increasing the segment length, which justifies the usage of multi-segment lengths strategy.

## Results

**Metrics Based on CMPS scores**

```{r hamby252-data, eval=TRUE, echo=FALSE}
# for hamby 252
N <- 3
CMPS_hamby252_results <- list()
CMPS_hamby252_results$span1 <- list(0.75, 0.25, 0.25)
CMPS_hamby252_results$signame <-
  list("sigs75", "sigs25", "sigs25_1062")
CMPS_hamby252_results$npeaks.set <-
  list(c(5, 3, 1),
       c(5, 3, 1),
       c(10, 6, 2))
CMPS_hamby252_results$seg_length <- list(50, 50, 50)
CMPS_hamby252_results$Tx <- list(25, 25, 25)
CMPS_hamby252_results$titlee <- list()
CMPS_hamby252_results$filename <- list()
for (i in 1:N) {
  CMPS_hamby252_results$titlee[[i]] <-
    paste0(
      "npeaks.set=c(",
      paste(CMPS_hamby252_results$npeaks.set[[i]], collapse = ","),
      ")",
      ", len=",
      CMPS_hamby252_results$seg_length[[i]],
       ", Tx=",
      CMPS_hamby252_results$Tx[[i]],
      ", \nspan1=",
      CMPS_hamby252_results$span1[[i]],
      ", span2=0.03"
    )
  CMPS_hamby252_results$filename[[i]] <- 
    paste(
      "hamby252",
      CMPS_hamby252_results$span1[[i]]*100,
      paste(CMPS_hamby252_results$npeaks.set[[i]], collapse = "-"),
      CMPS_hamby252_results$seg_length[[i]],
      CMPS_hamby252_results$Tx[[i]],
      sep = "_"
    )
}
CMPS_hamby252_results$cmps.table <- list()
CMPS_hamby252_results$plot <- list()

for(i in 1:N){
  CMPS_hamby252_results$cmps.table[[i]] <- 
  read.csv(file = paste("./data/", 
                        CMPS_hamby252_results$filename[[i]], 
                        ".csv",
                        sep = ""))
}

com.title252 <- expression(paste(
  "Hamby 252 - ", CMPS[max], " and ", bar(CMPS)[max], " Distribution"
))

# generate plots
for (i in 1:3) {
  hamby252.cmps <- CMPS_hamby252_results$cmps.table[[i]]
  
  hamby252.plot.list <- list()
  titlee <- CMPS_hamby252_results$titlee[[i]]
  
  hamby252.plot.list[[1]] <- hamby252.cmps %>% ggplot() +
    geom_histogram(aes(x = cmps.max.m,
                       fill = as.factor(type_truth)), binwidth = 1) +
    labs(
      fill = "Comparison Type",
      x = expression(CMPS[max]),
      # title = expression(paste("Hamby252 - ", CMPS[max], " Distribution")),
      subtitle = titlee
    ) +
    scale_x_continuous(breaks = seq(0, 27, 1)) +
    theme_bw() +
    theme(panel.grid.minor = element_blank()) +
    font("x.text", size = 6) +
    scale_fill_manual(values=c("darkorange", "darkgrey"))
    
  hamby252.plot.list[[2]] <- hamby252.cmps %>% ggplot() +
    geom_histogram(aes(x = cmps.maxbar.m,
                       fill = as.factor(type_truth)), binwidth = 1) +
    labs(
      x = expression(bar(CMPS)[max]),
      fill = "Comparison Type",
      # title = expression(paste(
      #   "Hamby252 - ", bar(CMPS)[max], " Distribution"
      # )),
      subtitle = titlee
    ) +
    scale_x_continuous(breaks = seq(0, 24, 1)) +
    theme_bw() +
    theme(panel.grid.minor = element_blank()) +
    scale_fill_manual(values=c("darkorange", "darkgrey"))
  
  plot <- ggarrange(plotlist = hamby252.plot.list,
                    nrow = 1,
                    ncol = 2,
                    common.legend = TRUE, legend = "bottom")
  plot <- annotate_figure(plot, 
                          top = text_grob(com.title252))
  CMPS_hamby252_results$plot[[i]] <- plot
}

```


```{r hamby44-data, eval=TRUE, echo=FALSE}
N <- 3
CMPS_hamby44_results <- list()
CMPS_hamby44_results$span1 <- list(0.25, 0.25, 0.75)
CMPS_hamby44_results$signame <-
  list("sigs25_531", "sigs25_1061", "sigs75_531")
CMPS_hamby44_results$npeaks.set <-
  list(c(5, 3, 1),
       c(10, 6, 1),
       c(5, 3, 1))
CMPS_hamby44_results$seg_length <- as.list(rep(61, 3))
CMPS_hamby44_results$Tx <- as.list(rep(30, 3))
CMPS_hamby44_results$titlee <- list()
CMPS_hamby44_results$filename <- list()
for (i in 1:N) {
  CMPS_hamby44_results$titlee[[i]] <-
    paste0(
      "npeaks.set=c(",
      paste(CMPS_hamby44_results$npeaks.set[[i]], collapse = ","),
      ")",
      ", len=",
      CMPS_hamby44_results$seg_length[[i]],
       ", Tx=",
      CMPS_hamby44_results$Tx[[i]],
      ", \nspan1=",
      CMPS_hamby44_results$span1[[i]],
      ", span2=0.03"
    )
  CMPS_hamby44_results$filename[[i]] <- 
    paste(
      "hamby44",
      CMPS_hamby44_results$span1[[i]]*100,
      paste(CMPS_hamby44_results$npeaks.set[[i]], collapse = "-"),
      CMPS_hamby44_results$seg_length[[i]],
      CMPS_hamby44_results$Tx[[i]],
      sep = "_"
    )
}
CMPS_hamby44_results$cmps.table <- list()
CMPS_hamby44_results$plot <- list()

for(i in 1:N){
  CMPS_hamby44_results$cmps.table[[i]] <- 
  read.csv(file = paste("./data/", 
                        CMPS_hamby44_results$filename[[i]], 
                        ".csv",
                        sep = ""))
}

com.title44 <- expression(paste(
  "Hamby 44 - ", CMPS[max], " and ", bar(CMPS)[max], " Distribution"
))

# generate plots
for (i in 1:3) {
  hamby44.cmps <- CMPS_hamby44_results$cmps.table[[i]]
  
  hamby44.plot.list <- list()
  titlee <- CMPS_hamby44_results$titlee[[i]]
  
  hamby44.plot.list[[1]] <- hamby44.cmps %>% ggplot() +
    geom_histogram(aes(x = cmps.max.m,
                       fill = as.factor(type_truth)), binwidth = 1) +
    labs(
      fill = "Comparison Type",
      x = expression(CMPS[max]),
      # title = expression(paste("Hamby252 - ", CMPS[max], " Distribution")),
      subtitle = titlee
    ) +
    scale_x_continuous(breaks = seq(0, 27, 1)) +
    theme_bw() +
    theme(panel.grid.minor = element_blank()) +
    font("x.text", size = 6)+
    scale_fill_manual(values=c("darkorange", "darkgrey"))
    
  hamby44.plot.list[[2]] <- hamby44.cmps %>% ggplot() +
    geom_histogram(aes(x = cmps.maxbar.m,
                       fill = as.factor(type_truth)), binwidth = 1) +
    labs(
      x = expression(bar(CMPS)[max]),
      fill = "Comparison Type",
      # title = expression(paste(
      #   "Hamby252 - ", bar(CMPS)[max], " Distribution"
      # )),
      subtitle = titlee
    ) +
    scale_x_continuous(breaks = seq(0, 24, 1)) +
    theme_bw() +
    theme(panel.grid.minor = element_blank()) +
    scale_fill_manual(values=c("darkorange", "darkgrey"))
  
  plot <- ggarrange(plotlist = hamby44.plot.list,
                    nrow = 1,
                    ncol = 2,
                    common.legend = TRUE, legend = "bottom")
  plot <- annotate_figure(plot, 
                          top = text_grob(com.title44))
  CMPS_hamby44_results$plot[[i]] <- plot
}
```

As presented in the work of @cmps, researchers applied the CMPS method to one of the Hamby set scans (Hamby 252). In order to show that our implementation of the CMPS algorithm is able to reproduce the results in @cmps and be used for other data sets, we applied our implementation to both Hamby set 252 and Hamby set 44. Because the CMPS algorithm works with bullet signatures in our case, we conducted some data-processing: for both Hamby 252 and Hamby 44, we started with x3p files in the database, followed the framework proposed by @aoas with the same set of parameters, removed damaged bullet scans, obtained bullet signatures for each bullet land engraving, and removed outliers in bullet signatures. Note that researchers of @cmps used a different framework to obtain bullet signatures. However, since their work is not open-source, we were not able to follow their framework and were only able to reproduce the results for Hamby set 252 qualitatively.

The CMPS score can be considered as a similarity score of two signatures. Then in order to obtain a similarity score of two bullets based on CMPS scores, researchers introduced two similarity metrics, $\mathrm{CMPS_{max}}$ and $\mathrm{\overline{CMPS}_{max}}$, for bullet-level comparisons [@cmps]. $\mathrm{CMPS_{max}}$ is the highest CMPS score obtained among all pairwise bullet signature comparisons. And $\mathrm{\overline{CMPS}_{max}}$ is the highest possible mean CMPS score of signature comparisons that are in the same phase.

In general, we assume each bullet has $n$ land engravings (in our case $n=6$). Let $c_{ij}$ denote the CMPS score of a comparison between bullet 1 land $i$ and bullet 2 land $j$, for $i,j = 1, \dots, n$. Let $\mathcal{P}_k$ denote bullet land pairs in phase $k$ for $k = 0, \dots, n-1$, and $\mathcal{P}_k = \{ (i,j): i = 1, \dots, n ; j = (i + k) - n \cdot \mathbbm{1}_{i + k > n} \}$, where $\mathbbm{1}_A$ denotes an indicator function. For example, $\mathcal{P}_1 = \{ (1,2), (2,3), (3,4), (4,5), (5,6), (6,1) \}$ when $n = 6$.

With that, the two measures to evaluate accuracy used in @cmps are defined as 
\begin{align}
\mathrm{CMPS_{max}} &= \max_{i,j} c_{ij}, \text{and }\\
\mathrm{\overline{CMPS}_{max}} &= \max_{k} \left[  \frac{1}{n} \sum_{(i,j) \in \mathcal{P}_k} c_{ij}\right].
\end{align}
\hh{XXX point out that neither of these measures evaluates the non-matches, and introduce CMPS diff here}

We can continue with the example used in previous sections. `bullets` contains bullet signatures of two bullets, `bullet1` and `bullet2`. As mentioned before, each bullet has six land engravings, resulting in six bullet signatures. Thus, there are 36 pairwise bullet signature comparisons, resulting in 36 $c_{ij}$ values in total. We use multi-segment lengths strategy with default parameters to compute these CMPS scores, and the result is shown in \autoref{fig:tiles}. We can see that in this example, 

$$
\mathrm{CMPS_{max}} =  \max_{i,j} c_{ij} = 17
$$

and since bullet lands in phase $\mathcal{P}_1$ gives the highest mean CMPS score, we have

$$
\begin{aligned}
\mathrm{\overline{CMPS}_{max}} &= \frac{1}{6} \sum_{(i,j) \in \mathcal{P}_1} c_{ij} \\
                        &= \frac{1}{6} (c_{12} + c_{23} + c_{34} + c_{45} + c_{56} + c_{61}) \\
                        &= \frac{1}{6} (3+17+14+10+15+16) \\
                        &= 12.5
\end{aligned}
$$


```{r tiles, echo=FALSE, fig.cap="CMPS scores of all 36 pairwise bullet signature comparisons for two bullets. Land engraving pairs generated by the same land (KM comparisons) are highlighted", out.width=".7\\textwidth", fig.align="center"}
dframe <- dframe %>% mutate(
  landA = paste0("L", landA),
  landB = paste0("L", landB),
  landB = factor(landB, levels = paste0("L", c(2:6,1))),
  bulletA = paste0("Bullet ", bulletA),
  bulletB = paste0("Bullet ", bulletB)
)

dframe %>% ggplot(aes(x = landA, y = landB, fill = cmps_score)) + 
  geom_tile() + 
  geom_tile(aes(colour="same land"), fill=NA, data = dframe %>% filter(samesource), size=1) + 
  scale_fill_gradient2("CMPS score", low = "gray80", high = "darkorange", midpoint = 6) + 
  scale_colour_manual("Source", values="darkorange") +
  facet_grid(bulletB ~ bulletA) + xlab("Bullet1 Lands") + 
  ylab("Bullet2 Lands") + 
  geom_text(aes(label=cmps_score)) +
  theme_bw() +
  theme(aspect.ratio = 1)
# dframe %>% ggplot(aes(x = landA, y = landB, fill = cmps_score/cmps_nseg)) +
#   geom_tile() +
#   geom_tile(aes(colour="same land"), fill=NA, data = dframe %>% filter(samesource), size=1) +
#   scale_fill_gradient2("CMPS score", low = "gray80", high = "darkorange", midpoint = 6/25) +
#   scale_colour_manual("Source", values="darkorange") +
#   facet_grid(bulletB ~ bulletA) + xlab("Bullet1 Lands") +
#   ylab("Bullet2 Lands") +
#   geom_text(aes(label=round(cmps_score/cmps_nseg, digits = 2))) +
#   theme_bw() +
#   theme(aspect.ratio = 1)
```



<!-- based on CMPS scores of bullet signature comparisons. For example, there are in total 6 $\times$ 6 signature comparisons in order to compare two bullets in Hamby study since each bullet has 6 LEAs and each LEA generates a bullet signature. And a CMPS score will be found for every signature comparison. $\mathrm{CMPS_{max}}$ is the highest CMPS score among all signature comparisons. And $\mathrm{\overline{CMPS}_{max}}$ is the highest possible average CMPS score of signature comparisons that are in the same phase. -->


<!-- In this example, $\mathrm{CMPS_{max}}$, the highest CMPS score, is 17, and $\mathrm{\overline{CMPS}_{max}}$, the highest possible mean CMPS score of comparisons in the same phase, is $()/6=12.5$.  -->

**Hamby 252**

\autoref{fig:result1_252} shows the distribution of $\mathrm{CMPS_{max}}$ and $\mathrm{\overline{CMPS}_{max}}$ after we applied the CMPS algorithm to Hamby set 252 with the multi-segment lengths strategy. Although the CMPS scores we found here are not exactly the same as those presented in @cmps since we don't have the exact parameters and functions used by the researchers, the results we obtained qualitatively agree with their results. For both $\mathrm{CMPS_{max}}$ and $\mathrm{\overline{CMPS}_{max}}$ we can observe a clear separation between the known matching comparisons (KM) and known non-matching comparisons (KNM).  

The parameters we used in `extract_feature_cmps` are:

```{r, eval=FALSE}
extract_feature_cmps(
  x, y,
  seg_length = 50,
  Tx = 25,
  npeaks.set = c(5,3,1),
  include = "nseg"
)
```

Note that for Hamby set 252, one unit represents 1.5625 \textmu m so setting `seg_length = 50` makes each basis segment have length 78.125 \textmu m. And `Tx = 25` makes the tolerance zone be $\pm 39.0625$ \textmu m. This is to mimic the parameters used in @cmps.

<!-- this is figure 2 -->
```{r result1_252, echo=FALSE, out.width="400px", fig.cap="Distribution of $\\mathrm{CMPS_{max}}$ and $\\mathrm{\\overline{CMPS}_{max}}$ for Hamby 252; removed outliers; seg\\_length = 50, Tx = 25, npeaks.set = c(5,3,1) ", fig.height=3}
# [4] "span1=0.25, span2=0.03, rm_outliers = TRUE, 5025, 531"  
# knitr::include_graphics("img/hamby252_v1.png", dpi = 100)
CMPS_hamby252_results$plot[[2]]
```



**Hamby 44**

For Hamby set 44 we not only generated comparable results but also used different sets of parameters to examine their potential effects. 

\autoref{fig:result1_44} shows the Hamby 44 results that are comparable with Hamby 252 results. The parameters used in `extract_feature_cmps` are: 

```{r, eval=FALSE}
extract_feature_cmps(
  x, y,
  seg_length = 61, 
  Tx = 30,
  npeaks.set = c(5,3,1),
  include = "nseg"
)
```

Since the Hamby set 44 scans have a different scanning resolution, we need to adjust the value of `seg_length` and `Tx` accordingly. One unit in Hamby 44 represents 1.29 \textmu m. Thus, we make `seg_length = 61` and `Tx = 30` to ensure that each basis segment has length 78.69 \textmu m, and the tolerance zone is $\pm 38.7$ \textmu m. Again, we are able to see a clear separation between the KM comparisons and the KNM comparisons, but it would be better if the separation can be further enlarged, which motivates us to examine different sets of parameters.


```{r result1_44, echo=FALSE, out.width="400px", fig.cap="Distribution of $\\mathrm{CMPS_{max}}$ and $\\mathrm{\\overline{CMPS}_{max}}$ for Hamby 44; removed outliers; seg\\_length = 61, Tx = 30, npeaks.set = c(5,3,1), span1=0.25", fig.height=3}
# [1] "span1=0.25, span2=0.03, rm_outliers"
# knitr::include_graphics("img/hamby44_v1.png", dpi = 100)
CMPS_hamby44_results$plot[[1]]
```

\autoref{fig:result2_44} shows another Hamby set 44 results, but we changed the value of `npeaks.set` while holding other parameters fixed. In this result, `npeaks.set` is `c(10,6,1)` instead of `c(5,3,1)`. We can see that this results in an increased separation between KM comparisons and KNM comparisons. This shows that the parameters used in the CMPS algorithm could potentially affect the CMPS results, and an open-source implementation of the algorithm will facilitate efforts of cross-validating these parameters.

<!-- this is figure 4 -->

```{r result2_44, echo=FALSE, out.width="400px", fig.cap="Distribution of $\\mathrm{CMPS_{max}}$ and $\\mathrm{\\overline{CMPS}_{max}}$ for Hamby 44; removed outliers; seg\\_length = 61, Tx = 30, npeaks.set = c(10,6,1), span1=0.25 ", fig.height=3}
# [5] "span1=0.25, span2=0.03, rm_outliers, c(10,6,1)"
# knitr::include_graphics("img/hamby44_c1_v1.png", dpi = 100)
CMPS_hamby44_results$plot[[2]]
```

For the third result of Hamby 44, we changed a parameter used in the data-processing procedure. `span1=0.25` is used for the previous results. Here, we change the span of 0.75, which captures a more global pattern in the bullet signatures.
<!-- For the results above we used `span1=0.25` in the function `cc_get_signature` when computing the  = ; however, in this example we used `span1=0.75` and changed the characteristic of those  = . -->
As we can see in \autoref{fig:result3_44}, changing some characteristics of bullet signatures will also change the final CMPS results. 
\autoref{tab:table1} presents some summary statistics of the Hamby 44 results above. These summary statistics are used to show the separation between the KM and KNM groups in the distribution of both $\mathrm{CMPS_{max}}$ and $\mathrm{\overline{CMPS}_{max}}$. As shown in \autoref{tab:table1}, some parameter settings are better than others in terms of the separation between the two distributions. However, we are not suggesting any set of parameters to users since further research is needed to provide a comprehensive cross-validation on these parameters, which can be facilitated by an open-source implementation of the CMPS algorithm.


<!-- this is figure 5 -->

```{r result3_44, echo=FALSE, out.width="400px", fig.cap="Distribution of $\\mathrm{CMPS_{max}}$ and $\\mathrm{\\overline{CMPS}_{max}}$ for Hamby 44; removed outliers; seg\\_length = 61, Tx = 30, npeaks.set = c(5,3,1), span1=0.75", fig.height=3}
# [4] "span1=0.75, span2=0.03, rm_outliers"  
# knitr::include_graphics("img/hamby44_c2_v1.png", dpi = 100)
CMPS_hamby44_results$plot[[3]]
```

```{r table1, echo=FALSE, warning=FALSE}
# rtt <- readRDS("summary_table.rds")
# colnames(rtt) <- 
rtt <- data.frame(parameters = c("span1=0.25, (5, 3, 1)", "span1=0.25, (10, 6, 1)", "span1=0.75, (5, 3, 1)"),
                  p1 = c(7,9,6),
                  p2 = c(10, 13, 11),
                  p3 = c(3.6, 4.833, 3.167),
                  p4 = c(6.667, 9.167, 6.6))
colnames(rtt) <- c("Parameters",
                   "$\\mathrm{CMPS_{max}}$ KNM's max",
                   "$\\mathrm{CMPS_{max}}$ KM's min",
                   "$\\mathrm{\\overline{CMPS}_{max}}$ KNM's max",
                   "$\\mathrm{\\overline{CMPS}_{max}}$ KM's min")

knitr::kable(rtt, "latex", booktabs = TRUE, escape = FALSE,
             caption = "min and max of $\\mathrm{CMPS_{max}}$ and $\\mathrm{\\overline{CMPS}_{max}}$ showing the separation between KNM and KM",
             row.names = FALSE, digits = 4) %>% 
  column_spec(2:5, width = "2cm")
```

The codes generating those results can be found on Github at \url{https://github.com/willju-wangqian/CMPSpaper/tree/main/reproducible}


## Conclusion

In this paper we presented the CMPS package, an open-source implementation of the Congruent Matching Profile Segments (CMPS) algorithm [@cmps], and applied it to two datasets in Hamby study [@hamby] to show its potential for further research. 
The CMPS algorithm was proposed by NIST in 2019 and was made for objective tool marks comparisons. 
We introduced the basic logic of the CMPS algorithm and how it is implemented in the CMPS package. We also showcased the functionality of the CMPS package with a small dataset example that is included in the package.
In the CMPS package we also implemented some graphing tools for users to visualize results generated by our functions and to have a better understanding of both the algorithm and the results. 

Additionally, we applied the CMPS package to two datasets in Hamby study (Hamby set 252 and Hamby set 44), and the results we obtained were promising since we were able to reproduce the results in @cmps qualitatively and achieve a clear separation between the known-match (KM) comparisons and known-nonmatch (KNM) comparisons. However, the results of Hamby set 44 suggested that the CMPS method is sensitive to the choice of parameters in the algorithm, such as the length of basis segments and the number of peaks detected at each segment level. This indicates that further research is needed to provide a comprehensive cross-validation on parameters used the algorithm. Moreover, we might want to compare the two versions of the CMPS algorithm in the future as well.

The CMPS package as an open-source implementation introduces the CMPS algorithm to the `R` community and allows people to use it for their own projects. It would also facilitate future studies on parameter cross-validations, method comparisons, and the development of statistical methods for modeling KM and KNM CMPS score distributions, which can potentially be used to estimate error rates or define an identification criterion.  

<!-- ### About this format and the R Journal requirements -->

<!-- `rticles::rjournal_article` will help you build the correct files requirements:  -->

<!-- * A R file will be generated automatically using `knitr::purl` - see -->
<!-- https://bookdown.org/yihui/rmarkdown-cookbook/purl.html for more information. -->
<!-- * A tex file will be generated from this Rmd file and correctly included in -->
<!-- `RJwapper.tex` as expected to build `RJwrapper.pdf`. -->
<!-- * All figure files will be kept in the default rmarkdown `*_files` folder. This -->
<!-- happens because `keep_tex = TRUE` by default in `rticles::rjournal_article` -->
<!-- * Only the bib filename is to modifed. An example bib file is included in the -->
<!-- template (`RJreferences.bib`) and you will have to name your bib file as the -->
<!-- tex, R, and pdf files. -->
